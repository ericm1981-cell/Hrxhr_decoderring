<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>HPR Quick Coach</title>
<style>
  :root{
    --bg:#f6f8fc; --card:#ffffff; --text:#0f172a; --muted:#64748b; --line:#e5e7eb;
    --blue:#0b3aa8; --blue2:#1e4fbf; --orange:#f97316;
    --good:#16a34a; --bad:#dc2626; --warn:#d97706;
    --shadow:0 10px 26px rgba(2,6,23,.08); --radius:14px;
    --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:var(--bg);color:var(--text)}
  .topbar{
    display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap;
    padding:12px 14px;background:linear-gradient(90deg,var(--blue),var(--blue2));color:#fff;border-bottom:3px solid var(--orange)
  }
  .topbar .left{display:flex;flex-direction:column;gap:4px;min-width:240px}
  .topbar h1{margin:0;font-size:15px;font-weight:950;letter-spacing:.2px}
  .topbar .sub{margin:0;font-size:11.5px;opacity:.92;line-height:1.25}
  .pill{display:inline-flex;align-items:center;gap:8px;background:rgba(255,255,255,.16);
    border:1px solid rgba(255,255,255,.22);border-radius:999px;padding:6px 10px;font-size:12px}
  .mono{font-family:var(--mono)}
  .wrap{max-width:1180px;margin:0 auto;padding:10px 12px}
  .grid{display:grid;grid-template-columns:1fr;gap:10px}
  @media(min-width:1020px){.grid{grid-template-columns:1.25fr .75fr}}
  .card{background:var(--card);border:1px solid var(--line);border-radius:var(--radius);box-shadow:var(--shadow);padding:12px}
  .card h2{margin:0 0 8px 0;font-size:12px;letter-spacing:.25px;text-transform:uppercase;color:var(--muted)}
  .row{display:grid;grid-template-columns:1fr;gap:8px}
  @media(min-width:820px){.row.cols4{grid-template-columns:1fr 1fr 1fr 1fr}.row.cols3{grid-template-columns:1fr 1fr 1fr}}
  label{display:block;font-size:11px;color:var(--muted);margin-bottom:4px;font-weight:900}
  input,select{width:100%;border:1px solid var(--line);border-radius:12px;padding:9px 10px;font-size:14px;outline:none;background:#fff;color:var(--text)}
  .btn{border:1px solid var(--line);background:#fff;color:var(--text);border-radius:10px;padding:8px 10px;font-weight:950;font-size:12px;cursor:pointer}
  .btn.primary{background:var(--blue2);color:#fff;border-color:transparent}
  .btn.primary:hover{background:var(--blue)}
  .btnline{display:flex;flex-wrap:wrap;gap:8px}
  .btnline .btn{border-radius:999px}
  .btn.active{outline:3px solid rgba(249,115,22,.25);border-color:rgba(249,115,22,.45)}
  .actions{display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-top:8px}
  .kpis{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  @media(min-width:820px){.kpis{grid-template-columns:1fr 1fr 1fr 1fr 1fr}}
  .kpi{border:1px solid var(--line);border-radius:14px;padding:10px;background:#fff}
  .kpi .k{font-size:11px;color:var(--muted);font-weight:900}
  .kpi .v{margin-top:4px;font-size:18px;font-weight:1000}
  .kpi .v.big{font-size:22px}
  .kpi .v.good{color:var(--good)}
  .kpi .v.bad{color:var(--bad)}
  .status{
    border:1px solid var(--line);border-radius:16px;padding:12px;
    background:linear-gradient(180deg,#fff,#fbfdff);
  }
  .status.good{border-color:rgba(22,163,74,.35)}
  .status.bad{border-color:rgba(220,38,38,.35)}
  .status.warn{border-color:rgba(217,119,6,.35)}
  .statusTop{display:flex;justify-content:space-between;gap:10px;align-items:flex-start;flex-wrap:wrap}
  .status .title{font-size:18px;font-weight:1050;margin:0}
  .title.good{color:var(--good)}
  .title.bad{color:var(--bad)}
  .title.warn{color:var(--warn)}
  .status .detail{margin-top:6px;color:var(--muted);font-size:12px;line-height:1.25}
  .badge{display:inline-flex;align-items:center;gap:6px;border-radius:999px;padding:4px 8px;font-size:11px;font-weight:1000;border:1px solid var(--line);background:#fff}
  .badge.good{border-color:rgba(22,163,74,.35);color:var(--good)}
  .badge.bad{border-color:rgba(220,38,38,.35);color:var(--bad)}
  .tiny{font-size:11px;color:var(--muted);line-height:1.25}
  details{border:1px dashed rgba(100,116,139,.35);border-radius:12px;padding:8px 10px;background:#fff}
  details summary{cursor:pointer;font-weight:900;color:var(--muted);font-size:11.5px}
  .table{width:100%;border:1px solid var(--line);border-radius:12px;overflow:hidden;border-collapse:separate;border-spacing:0;font-size:12px}
  .table th,.table td{padding:8px 10px;border-bottom:1px solid var(--line);text-align:left}
  .table th{background:#f8fafc;color:var(--muted);font-size:11px;text-transform:uppercase;letter-spacing:.2px}
  .table tr:last-child td{border-bottom:none}
</style>
</head>
<body>
  <div class="topbar">
    <div class="left">
      <h1>HPR Quick Coach</h1>
      <div class="sub">Current HPR = <b>Produced ÷ Expected-to-Now</b> (time-of-day, breaks excluded). Includes forecasts for <b>0 / +1 / +2 OT</b>.</div>
      <div class="btnline" id="lineButtons"></div>
    </div>
    <div class="pill"><span>Now</span><span class="mono" id="nowClock">--:--</span></div>
  </div>

  <div class="wrap">
    <div class="grid">
      <section class="card">
        <h2>Inputs</h2>
        <div class="row cols4">
          <div>
            <label>Shift</label>
            <select id="shiftSel">
              <option value="DAY">Day Shift (06:00–14:30)</option>
              <option value="PIC2">Pictures 2nd Shift (15:30–24:00)</option>
            </select>
            <div class="tiny">Pictures = cumulative day totals (Shift 1 + Shift 2).</div>
          </div>
          <div>
            <label>Today's Schedule (units)</label>
            <input id="schedUnits" type="number" min="0" inputmode="numeric" />
          </div>
          <div>
            <label>Produced So Far (total today)</label>
            <input id="doneUnits" type="number" min="0" inputmode="numeric" />
          </div>
          <div>
            <label>Extra 10-min break on 10-hr day</label>
            <select id="extraBreakSel">
              <option value="on">ON</option>
              <option value="off">OFF</option>
            </select>
          </div>
        </div>

        <div class="actions">
          <button class="btn primary" id="calcBtn" type="button">Update</button>
          <span class="tiny">Updates live as you type schedule/produced.</span>
        </div>

        
        <div style="margin-top:10px" class="kpis">
          <div class="kpi">
            <div class="k">Capacity (units)</div>
            <div class="v big" id="capUnits">—</div>
            <div class="tiny">What we’re measured against (455 min available).</div>
          </div>
          <div class="kpi">
            <div class="k">Expected-to-Now (units @100%)</div>
            <div class="v big" id="expectedNow">—</div>
          </div>
          <div class="kpi">
            <div class="k">Current HPR%</div>
            <div class="v big" id="hprNow">—</div>
          </div>
          <div class="kpi">
            <div class="k">Takt Time (sec/unit)</div>
            <div class="v big" id="taktSec">—</div>
            <div class="tiny">Based on today's schedule (not capacity).</div>
          </div>
          <div class="kpi">
            <div class="k">Finish Time (if schedule &lt; capacity)</div>
            <div class="v big" id="finish">—</div>
            <div class="tiny" id="finishNote"></div>
          </div>
        </div>

        <div style="margin-top:10px">
edule (not capacity).</div>
          </div>
          <div class="kpi">
            <div class="k">Finish Time (if schedule &lt; capacity)</div>
            <div class="v big" id="finish">—</div>
            <div class="tiny" id="finishNote"></div>
          </div>
        </div>

        <div style="margin-top:10px">
<div style="margin-top:10px">
          <h2>Forecast by OT</h2>
          <table class="table">
            <thead>
              <tr>
                <th>Scenario</th>
                <th>Avail Min Remaining</th>
                <th>Forecast End Units</th>
                <th>Delta vs Schedule</th>
                <th>Status</th>
              </tr>
            </thead>
            <tbody id="otBody"></tbody>
          </table>
        </div>

        <details style="margin-top:10px">
          <summary>Break/Lunch settings (per line)</summary>
          <div class="tiny" style="margin-top:8px">Defaults set from your note. Edit only if a line changes.</div>
          <div class="row cols3" style="margin-top:8px">
            <div>
              <label>Break</label>
              <input id="br1" class="mono" placeholder="HH:MM-HH:MM" />
            </div>
            <div>
              <label>Lunch</label>
              <input id="lunch" class="mono" placeholder="HH:MM-HH:MM" />
            </div>
            <div>
              <label>Optional 2nd Break</label>
              <input id="br2" class="mono" placeholder="HH:MM-HH:MM (blank ok)" />
            </div>
          </div>
          <div class="actions">
            <button class="btn" id="saveBreaksBtn" type="button">Save Breaks</button>
            <span class="tiny">Applies to expected-now, HPR, and all OT forecasts.</span>
          </div>
        </details>
      </section>

      <aside class="card">
        <h2>Status & Recovery</h2>
        <div class="status warn" id="statusBox">
          <div class="statusTop">
            <div>
              <div class="title warn" id="statusTitle">Waiting for input</div>
              <div class="detail" id="statusDetail">Select a line, enter schedule + produced. Recovery guidance updates instantly.</div>
            </div>
            <div class="pill" style="background:rgba(15,23,42,.12);border-color:rgba(15,23,42,.12);color:var(--text)">
              <span>Avail Min (0 OT)</span><span class="mono" id="avail0">—</span>
            </div>
          </div>
          <div style="margin-top:10px" id="recoveryBox" class="detail">
            Run Update to generate the recovery plan.
          </div>
        </div>

        <div style="margin-top:12px" class="tiny">
          <b>Break defaults loaded automatically:</b><br/>
          Line 1 & Pictures: 09:00–09:15, lunch 11:45–12:15<br/>
          Casement: 08:45–09:00, lunch 11:15–11:45<br/>
          Line 2 & 3: 09:10–09:25, lunch 12:15–12:45
        </div>
      </aside>
    </div>
  </div>

<script>
const CAPACITY = {"LINE1":260,"LINE2":385,"LINE3":195,"CASEMENT":108,"PICTURES":115};

const SHIFT = {
  DAY: {start:"06:00", end:"14:30"},
  PIC2:{start:"15:30", end:"24:00"}
};

const BREAK_DEFAULTS = {
  "LINE1": {br1:"09:00-09:15", lunch:"11:45-12:15", br2:""},
  "PICTURES": {br1:"09:00-09:15", lunch:"11:45-12:15", br2:""},
  "CASEMENT": {br1:"08:45-09:00", lunch:"11:15-11:45", br2:""},
  "LINE2": {br1:"09:10-09:25", lunch:"12:15-12:45", br2:""},
  "LINE3": {br1:"09:10-09:25", lunch:"12:15-12:45", br2:""},
};

const LS = {
  line:"hprqc_line_v2",
  sched:"hprqc_sched_v2",
  breaks:"hprqc_breaks_v2",
  extra:"hprqc_extra_v2"
};

const $ = (id)=>document.getElementById(id);
function pad(n){return String(n).padStart(2,"0");}
function nowMin(){const d=new Date(); return d.getHours()*60+d.getMinutes();}
function parseHHMM(hhmm){ const [h,m]=hhmm.split(":").map(Number); return h*60+m; }
function fmtClock(mins){
  mins = ((mins%1440)+1440)%1440;
  const h=Math.floor(mins/60), m=Math.floor(mins%60);
  return pad(h)+":"+pad(m);
}
function parseRange(r){
  if(!r) return null;
  const parts=r.split("-");
  if(parts.length!==2) return null;
  const a=parts[0].trim(), b=parts[1].trim();
  if(!/^\d{2}:\d{2}$/.test(a) || !/^\d{2}:\d{2}$/.test(b)) return null;
  return {s:parseHHMM(a), e:parseHHMM(b)};
}
function overlap(aS,aE,bS,bE){
  const s=Math.max(aS,bS), e=Math.min(aE,bE);
  return Math.max(0,e-s);
}
function getLine(){ return localStorage.getItem(LS.line) || "LINE1"; }

function buildLineButtons(){
  const container=$("lineButtons");
  const lines=["LINE1","LINE2","LINE3","CASEMENT","PICTURES"];
  container.innerHTML="";
  lines.forEach(l=>{
    const b=document.createElement("button");
    b.className="btn";
    b.textContent = (l==="PICTURES") ? "PICTURES" : l;
    b.dataset.linebtn = l;
    b.onclick=()=>{ setLine(l); updateAll(); };
    container.appendChild(b);
  });
}

function setActiveButton(line){
  [...document.querySelectorAll("[data-linebtn]")].forEach(b=>{
    b.classList.toggle("active", b.dataset.linebtn===line);
  });
}

function loadBreaksForLine(line){
  const all = JSON.parse(localStorage.getItem(LS.breaks) || "{}");
  const b = all[line] || BREAK_DEFAULTS[line] || {br1:"",lunch:"",br2:""};
  $("br1").value = b.br1 || "";
  $("lunch").value = b.lunch || "";
  $("br2").value = b.br2 || "";
}

function saveBreaksForLine(line){
  const all = JSON.parse(localStorage.getItem(LS.breaks) || "{}");
  all[line] = {br1:$("br1").value.trim(), lunch:$("lunch").value.trim(), br2:$("br2").value.trim()};
  localStorage.setItem(LS.breaks, JSON.stringify(all));
}

function loadScheduleForLine(line){
  const o = JSON.parse(localStorage.getItem(LS.sched) || "{}");
  if(o[line]!==undefined) return o[line];
  return (line==="PICTURES") ? CAPACITY.PICTURES : CAPACITY[line];
}
function saveScheduleForLine(line, sched){
  const o = JSON.parse(localStorage.getItem(LS.sched) || "{}");
  o[line]=sched;
  localStorage.setItem(LS.sched, JSON.stringify(o));
}

function setLine(line){
  localStorage.setItem(LS.line,line);
  setActiveButton(line);
  loadBreaksForLine(line);
  $("schedUnits").value = loadScheduleForLine(line);
  $("shiftSel").value = (line==="PICTURES") ? "PIC2" : "DAY";
}

function computeAvail(shiftCode, breaks, otMinutes){
  const win = SHIFT[shiftCode];
  const start0=parseHHMM(win.start);
  const end0=parseHHMM(win.end) + otMinutes;
  let now = nowMin();
  let start=start0, end=end0, nowT=now;

  if(end>1440 && nowT<start) nowT += 1440;

  const endClamp = Math.min(nowT, end);
  const elapsedGross = Math.max(0, endClamp - start);
  const remGross = Math.max(0, end - Math.max(nowT, start));

  let subElapsed=0, subRem=0;
  for(const br0 of breaks){
    if(!br0) continue;
    let s=br0.s, e=br0.e;
    if(end>1440){
      if(s<start) s+=1440;
      if(e<=s) e+=1440;
    }
    subElapsed += overlap(start, endClamp, s, e);
    subRem += overlap(Math.max(nowT,start), end, s, e);
  }

  if(otMinutes>=120 && $("extraBreakSel").value==="on"){
    subRem += 10;
  }

  const elapsedAvail = Math.max(0, elapsedGross - subElapsed);
  const remAvail = Math.max(0, remGross - subRem);
  const plannedAvail = Math.max(1, elapsedAvail + remAvail);
  return {elapsedAvail, remAvail, plannedAvail};
}

function computeExpectedNowAndHPR(line, shiftCode, sched, done){
  const breaks = [parseRange($("br1").value.trim()), parseRange($("lunch").value.trim()), parseRange($("br2").value.trim())].filter(Boolean);

  if(line==="PICTURES" && shiftCode==="PIC2"){
    const dayBreaks = [parseRange("09:00-09:15"), parseRange("11:45-12:15")].filter(Boolean);
    const day0 = computeAvail("DAY", dayBreaks, 0);
    const pic0 = computeAvail("PIC2", breaks, 0);
    const plannedTotal = day0.plannedAvail + pic0.plannedAvail;
    const elapsedTotal = day0.plannedAvail + pic0.elapsedAvail;
    const expectedNow = sched * (elapsedTotal / plannedTotal);
    const hpr = (expectedNow>0) ? (done/expectedNow) : 0;
    return {expectedNow, hpr, plannedAvail0: plannedTotal, remAvail0: pic0.remAvail};
  }

  const base = computeAvail(shiftCode, breaks, 0);
  const expectedNow = sched * (base.elapsedAvail / base.plannedAvail);
  const hpr = (expectedNow>0) ? (done/expectedNow) : 0;
  return {expectedNow, hpr, plannedAvail0: base.plannedAvail, remAvail0: base.remAvail};
}

function setStatus(kind, title, detail){
  const box=$("statusBox");
  box.classList.remove("good","bad","warn");
  box.classList.add(kind);
  $("statusTitle").textContent = title;
  $("statusTitle").className = "title " + kind;
  $("statusDetail").textContent = detail;
}

function buildRecovery(kind, line, delta, remAvailMin){
  if(kind==="good"){
    return `<span class="badge good">GREEN</span> <b>Protect the day.</b><br/>
      • Protect the constraint: no starving / no blocking.<br/>
      • Next-hour discipline: micro-stop elimination + fast response to holds.<br/>
      • If the next hour flips RED → immediate recovery mode (no-stop window + responder).`;
  }
  const short = Math.abs(delta);
  const hrsLeft = remAvailMin/60;
  const addPerHr = (hrsLeft>0) ? (short/hrsLeft) : short;

  let focus = "Pick the biggest loss category and kill it in the next hour.";
  if(line==="LINE1") focus="Stabilize post-revamp: start/stop discipline, coverage, and quality hold containment.";
  if(line==="LINE2") focus="Constraint protection: keep bottleneck running; prevent downstream blocking; rapid response to minor stops.";
  if(line==="LINE3") focus="Stop stacking small losses: staging, standard work, quick reset on minor stops.";
  if(line==="CASEMENT") focus="Quality/changeover containment: rapid triage + reset standard work.";
  if(line==="PICTURES") focus="Cumulative day recovery: no-stop window + quick escalation on holds.";

  return `<span class="badge bad">RED</span> <b>Recovery required.</b><br/>
    • Short by <b>${short.toFixed(0)}</b> units at current HPR.<br/>
    • Need <b>+${addPerHr.toFixed(1)}</b> units/hr for the rest of the shift to recover.<br/>
    • Run a 60-min “no-stop window” + dedicated responder (TL/utility).<br/>
    • <b>Focus:</b> ${focus}<br/>
    • If next hour not improved → escalate (help/containment plan or OT decision).`;
}

function updateAll(){
  const line = getLine();
  const shiftCode = $("shiftSel").value;
  const capRef = (line==="PICTURES") ? CAPACITY.PICTURES : CAPACITY[line];
  $("capUnits").textContent = (line==="PICTURES") ? (capRef + " / shift") : String(capRef);
  const sched = Number($("schedUnits").value);
  const done = Number($("doneUnits").value);

  if(!Number.isFinite(sched) || sched<=0 || !Number.isFinite(done) || done<0){
    $("capUnits").textContent = (line==="PICTURES") ? (CAPACITY.PICTURES + " / shift") : String(CAPACITY[line]||"—");
    $("expectedNow").textContent="—";
    $("hprNow").textContent="—";
    $("taktSec").textContent="—";
    $("finish").textContent="—";
    $("finishNote").textContent="";
    $("avail0").textContent="—";
    $("otBody").innerHTML="";
    setStatus("warn","Waiting for input","Enter today's schedule and produced so far.");
    $("recoveryBox").textContent="Run Update to generate the recovery plan.";
    return;
  }

  const base = computeExpectedNowAndHPR(line, shiftCode, sched, done);
  $("expectedNow").textContent = base.expectedNow.toFixed(1);

  const hprPct = base.hpr*100;
  const hprEl = $("hprNow");
  hprEl.textContent = hprPct.toFixed(1) + "%";
  hprEl.classList.remove("good","bad");
  hprEl.classList.add(hprPct>=100 ? "good" : "bad");

  const takt = (base.plannedAvail0 / Math.max(1,sched)) * 60;
  $("taktSec").textContent = takt.toFixed(0);

  $("avail0").textContent = base.remAvail0.toFixed(0);

  // Forecast scenarios
  const breaks = [parseRange($("br1").value.trim()), parseRange($("lunch").value.trim()), parseRange($("br2").value.trim())].filter(Boolean);
  const scenarios = [{label:"0 OT",ot:0},{label:"+1 hr OT",ot:60},{label:"+2 hrs OT",ot:120}];

  const rows = scenarios.map(sc=>{
    let remAvail, plannedAvail;
    if(line==="PICTURES" && shiftCode==="PIC2"){
      const dayBreaks = [parseRange("09:00-09:15"), parseRange("11:45-12:15")].filter(Boolean);
      const day0 = computeAvail("DAY", dayBreaks, 0);
      const picX = computeAvail("PIC2", breaks, sc.ot);
      plannedAvail = day0.plannedAvail + picX.plannedAvail;
      remAvail = picX.remAvail;
    }else{
      const x = computeAvail(shiftCode, breaks, sc.ot);
      plannedAvail = x.plannedAvail;
      remAvail = x.remAvail;
    }
    const unitsPerMin100 = sched / plannedAvail;
    const fcstEnd = done + (unitsPerMin100 * base.hpr * remAvail);
    const delta = fcstEnd - sched;
    return {label:sc.label, remAvail, fcstEnd, delta};
  });

  const body = $("otBody");
  body.innerHTML="";
  rows.forEach(r=>{
    const ok = r.delta >= 0;
    const tr=document.createElement("tr");
    tr.innerHTML = `
      <td><b>${r.label}</b></td>
      <td class="mono">${r.remAvail.toFixed(0)}</td>
      <td class="mono">${r.fcstEnd.toFixed(1)}</td>
      <td class="mono">${(r.delta>=0?"+":"") + r.delta.toFixed(1)}</td>
      <td>${ok ? '<span class="badge good">GREEN</span>' : '<span class="badge bad">RED</span>'}</td>`;
    body.appendChild(tr);
  });

  const primary = rows[0];
  if(primary.delta >= 0){
    setStatus("good","GREEN (On Track)","At current HPR, you are projected to hit today’s schedule with 0 OT. Protect the constraint and prevent micro-stops.");
  }else{
    setStatus("bad","RED (Off Track)",`At current HPR, you are projected short with 0 OT. Use the recovery plan to close the gap.`);
  }
  $("recoveryBox").innerHTML = buildRecovery(primary.delta>=0 ? "good" : "bad", line, primary.delta, primary.remAvail);

  // Finish time if schedule < capacity
  const cap = (line==="PICTURES") ? CAPACITY.PICTURES : CAPACITY[line];
  if(sched < cap){
    const elapsedAvail = (base.expectedNow / sched) * base.plannedAvail0;
    const pace = (elapsedAvail>0) ? (done/elapsedAvail) : 0;
    const remainingUnits = Math.max(0, sched - done);
    const minsNeeded = (pace>0) ? (remainingUnits / pace) : Infinity;
    if(Number.isFinite(minsNeeded)){
      $("finish").textContent = fmtClock(nowMin() + minsNeeded);
      $("finishNote").textContent = "Schedule under capacity → estimated completion at current pace.";
    }else{
      $("finish").textContent = "—";
      $("finishNote").textContent = "";
    }
  }else{
    $("finish").textContent = "—";
    $("finishNote").textContent = "Schedule at/over capacity → finish depends on recovery/OT.";
  }

  saveScheduleForLine(line, sched);
  localStorage.setItem(LS.extra, $("extraBreakSel").value);
}

$("calcBtn").addEventListener("click", updateAll);
$("shiftSel").addEventListener("change", updateAll);
$("schedUnits").addEventListener("input", updateAll);
$("doneUnits").addEventListener("input", updateAll);
$("extraBreakSel").addEventListener("change", updateAll);
$("saveBreaksBtn").addEventListener("click", ()=>{
  saveBreaksForLine(getLine());
  updateAll();
});

function tickClock(){
  const d=new Date();
  $("nowClock").textContent = pad(d.getHours())+":"+pad(d.getMinutes());
}
setInterval(tickClock, 1000);
tickClock();

function init(){
  buildLineButtons();
  const savedLine = localStorage.getItem(LS.line);
  const line = (savedLine && CAPACITY[savedLine]!==undefined) ? savedLine : "LINE1";
  setLine(line);
  setActiveButton(line);
  const extra = localStorage.getItem(LS.extra);
  if(extra) $("extraBreakSel").value = extra;
  updateAll();
}
init();
</script>
</body>
</html>
